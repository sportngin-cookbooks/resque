#!/bin/bash
### BEGIN INIT INFO
# Provides:  resque
# Short-Description: resque - a Redis-backed Ruby library for creating background jobs
# Description:  resque - a Redis-backed Ruby library for creating background jobs, placing those jobs on multiple queues, and processing them later.
### END INIT INFO
. /etc/init.d/functions

log_daemon_msg () {
    # Dummy function to be replaced by LSB library.

    echo $@
}

LOGFILE="<%= @logfile %>"
RESQUE_CONF="<%= @resque_conf %>"
RESQUE_BIN="<%= @bin_file %>"
TIMEOUT="<%= @timeout %>"

# Start all the resque queues
do_start() {
  local pid_start
  log_daemon_msg "=> Starting Resque Queues.."
  pid_start=0
  for i in `cat $RESQUE_CONF`; do
    app=`echo $i | cut -d , -f 1`
    num_workers=`echo $i | cut -d , -f 2`
    queues=`echo $i | cut -d , -f 3-`
    for j in `seq $pid_start $(($pid_start + $num_workers - 1))`; do
      do_start_one $app $j $queues
    done
    pid_start=$((j+1))
  done
}

# Start/Restart a single resque queue
do_start_one() {
  local pidfile
  local pid

  pidfile=$1/tmp/pids/$2.pid
  if [ -e $pidfile ]; then
    pid=`cat $pidfile`
    # If the resque isn't running, run it, otherwise restart it.
    if [ "`ps -A -o pid= | grep -c $pid`" -eq 0 ]; then
      do_start_one_do $1 $2 $3
    else
      do_restart_one $1 $2 $3
    fi
  else
    do_start_one_do $1 $2 $3
  fi
}

do_start_one_do() {
  log_daemon_msg "--> Starting Resque $1-$3"
  log_daemon_msg "logging to $1/$LOGFILE"

  app=$1 index=$2 queues=$3 daemon $RESQUE_BIN
  log_daemon_msg "Started Resque $1-$3"
}

#
# Function that stops all the resque queues
#
do_stop() {
  log_daemon_msg "=> Stopping All resque workers"
  pid_start=0
  for i in `cat $RESQUE_CONF`; do
    app=`echo $i | cut -d , -f 1`
    num_workers=`echo $i | cut -d , -f 2`
    for j in `seq $pid_start $(($pid_start + $num_workers - 1))`; do
      do_stop_one $app $j
    done
    pid_start=$(($j+1))
  done
}
#
# Function that stops the daemon/service
#
do_stop_one() {
  local pidfile
  local pid
  log_daemon_msg "--> Stopping Resque $1-$2"

  pidfile=$1/tmp/pids/$2.pid
  if [ -e $pidfile ]; then
    pid=`cat $pidfile`
    if [ "`ps -A -o pid= | grep -c $pid`" -eq 0 ]; then
      log_daemon_msg "---> Resque $1-$2 isn't running."
    else
      log_daemon_msg "---> About to kill PID `cat $pidfile`"
      kill -QUIT $pid
      for i in `seq 1 $TIMEOUT`; do
        checkpid $pid || break
        sleep 1
      done
      if checkpid $pid ; then
        log_daemon_msg "Failed to kill Resque $1-$2 gracefully..hard shut down"
        kill -KILL $pid >/dev/null 2>&1
      fi
      # Many daemons don't delete their pidfiles when they exit.
      rm -f $pidfile
    fi
  else
    log_daemon_msg "---> No Resque $1-$2 here..."
  fi
  return 0
}

#
# Function that restarts the jungle
#
do_restart() {
  pid_start=0
  for i in `cat $RESQUE_CONF`; do
    app=`echo $i | cut -d , -f 1`
    num_workers=`echo $i | cut -d , -f 2`
    queues=`echo $i | cut -d , -f 3-`
    for j in `seq $pid_start $(($pid_start + $num_workers - 1))`; do
      do_restart_one $app $j $queues
    done
    pid_start=$(($j+1))
  done
}

#
# Function that sends a SIGUSR2 to the daemon/service
#
do_restart_one() {
  local pidfile
  local pid

  pidfile=$1/tmp/pids/$2.pid
  if [ -e $pidfile ]; then
    pid=`cat $pidfile`
    log_daemon_msg "--> About to restart Resque $1-$2"
    do_stop_one $1 $2 $3
    do_start_one_do $1 $2 $3
  else
    log_daemon_msg "--> Resque was not running..Starting"
    do_start_one_do $1 $2 $3
  fi
  return 0
}

start() {
  do_start
}

stop() {
  do_stop
}


case "$1" in
  start) start ;;
stop) stop ;;
  restart)
    stop
    start
    ;;
*)
  echo "Usage: $0 {start|stop|restart}" >&2
  exit 1
  ;;
esac

